<page>
    <title>プログラミング言語</title>
    <ns>0</ns>
    <id>69</id>
    <revision>
      <id>95443591</id>
      <parentid>94862128</parentid>
      <timestamp>2023-06-01T07:11:56Z</timestamp>
      <contributor>
        <username>Matsui123</username>
        <id>2090768</id>
      </contributor>
      <comment>/* 外部リンク */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="61208" xml:space="preserve">[[File:C_Hello_World_Program.png|リンク=https://en.wikipedia.org/wiki/File:C_Hello_World_Program.png|右|サムネイル|357x357ピクセル|[[C言語]]で書かれた単純なコンピュータープログラムの[[ソースコード]]。グレーの行は、人間のためにプログラムの説明をする[[自然言語]]で書かれた[[コメント (コンピュータ)|コメント]]。このプログラムを[[コンパイラ|コンパイル]]して[[実行ファイル|実行]]すると、「[[Hello world|Hello, world!]]」という文字が出力される。]]
'''プログラミング言語'''（プログラミングげんご、{{Lang-en|programming language}}）とは、[[プログラム (コンピュータ)|プログラム]]を記述するための[[人工言語]]&lt;ref&gt;[http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=33636 ISO 5127]—Information and documentation—Vocabulary, clause 01.05.10 で、プログラミング言語は「プログラムを記述するための人工言語」と定義されている。&lt;/ref&gt;。[[プログラム (コンピュータ)|コンピュータプログラム]]を書くために考案された、正確に定義された[[記号]]と[[規則]]のしくみ&lt;ref&gt;[https://www.lexico.com/definition/programming_language Lexico, definition of programming language]. A system of precisely defined symbols and rules devised for writing computer programs.&lt;/ref&gt;。以前は、しばしば'''プログラム言語'''と表記された。

== 概要 ==
プログラミング言語は、情報を組織し処理するタスクについての理解を容易にし、[[アルゴリズム]]を正確に表現することができる。特に、[[チューリング完全]]であることが特徴である&lt;ref&gt;{{cite book | last=MacLennan | first=Bruce J. | title=Principles of Programming Languages | page=1 | publisher=Oxford University Press | date=1987年 | id=ISBN 0-19-511306-3 }}&lt;/ref&gt;。

言語仕様と[[プログラム (コンピュータ)|プログラム]]とその入力データの組合せで、そのプログラムを実行したときの結果（外部から観測される振る舞い）が完全に指定できなければならない。

プログラミング言語は'''構文規則'''（自然言語に関する[[言語学]]で言う[[統語論]]の規則に類似したもの）と'''意味規則'''（自然言語の[[意味論 (言語学)|意味論]]に類似した規則）で定義される。形式的ないし非形式的（自然言語による）な仕様が（構文規則は形式的で、意味規則はそうでない、というものが多い）実装とは独立した文書で示される言語もあれば、実装のみの言語もある。

多くの言語は、新たなニーズを満たすべく設計され、他の言語と組み合わされ、最終的に使われなくなる。あらゆる用途に使える万能言語を設計しようという試みはいくつかあったが、そういう意味で成功した言語は存在しない
&lt;ref group="注釈"&gt;IBMは PL/I をリリースしたとき、やや野心的にマニュアルを ''The universal programming language PL/I'' (IBM Library; 1966) と名づけている。このタイトルはIBMが目標としていた無制限のサブセット化機能を反映している「PL/I は特定の応用に必要な部分を抜き出し、サブセットを分離可能なように設計されている」 ({{cite web |url=http://eom.springer.de/P/p072885.htm |title=Encyclopaedia of Mathematics » P  » PL/I |work=SpringerLink |accessdate=2006年6月29日}}).  [[Ada]]と[[UNCOL]]も同様の初期目標を持っていた。&lt;/ref&gt;。

プログラミング言語の開発の大きな流れに共通する傾向として、より高いレベルの[[抽象化 (計算機科学)|抽象化]]によってより高い問題解決能力を得ようとしてきた、ということが指摘されることがある。初期のプログラミング言語はコンピュータのハードウェアのレベルと極めて近かった。新たなプログラミング言語が開発される度に機能が追加され、プログラマはハードウェアの命令からより遠い形でアイデアを表現できるようになっていった。プログラミングをハードウェアから分離することで、プログラマの[[生産性]]は向上する&lt;ref&gt; Frederick P. Brooks, Jr.:  ''The Mythical Man-Month,'' Addison-Wesley, 1982, pp. 93-94 &lt;/ref&gt;。

毎年のように新たなプログラミング言語が作り出されている。2008年2月時点で、「コンピュータ言語辞典&lt;ref&gt;[http://hopl.murdoch.edu.au/ The Encyclopedia of Computer Languages] {{webarchive|url=https://web.archive.org/web/20110220044217/http://hopl.murdoch.edu.au/ |date=2011年2月20日 }} （Murdoch University、[[オーストラリア]]）&lt;/ref&gt;」には8,152種のプログラミング言語が記載されていた。

過去のプログラミング言語のなかの欠点と見なされた部分を解消するために、新たなプログラミング言語が構想され、作られてきた歴史がある。また多様なプログラミング言語が生み出される背景には、さまざまな事情があり、ハードウェアが時代とともに変化してきたことや、プログラミング言語というテクノロジーや[[コンピュータサイエンス]]の発展も影響しており、下のような諸事情もある。
* プログラムと言っても、個人が自分だけのために趣味で書く数行から数十行程度の短いプログラム（やスクリプト）から、数百人のプログラマが協働して企業の大規模なシステムのために書く長大なプログラムまで、様々なプログラムがある。
* プログラミング言語の記述に 簡潔さを求め、可読性が高いことを求め、バグが入り込みにくい記述を好むプログラマの方が多く、世の中では一般的である（特に、業務として、ミスの少ないプロの仕事としてプログラミングを行わなければいけない職業的プログラマで多い）一方で、ごちゃごちゃして難読で、一名で書くならともかく複数名でプログラムを書くと高頻度で誤読や[[バグ]]を招きがちな記述でもあまり気にしなかったり面白がる趣味的なプログラマも一部にいる。
* プログラムが搭載されるシステムも多様で、[[マイクロコントローラ]]、[[組み込みシステム]]から汎用[[デスクトップパソコン|デスクトップ]]PC、[[GPU]]そして[[スーパーコンピュータ]]まで様々あり、それぞれのシステムのハードウェアの特性や制約に合ったプログラムやプログラミング言語がある。
* もともとプログラミング言語はもっぱら大学のコンピュータサイエンスの研究室や大手企業の研究所などの奥深くばかりで開発されていたのだが、ここ数十年では個人が趣味的に新しいプログラミング言語を構想しそのコンパイラを自分で書くための書籍なども時折出版されるようになり、つまり世の中の普通の人が新たなプログラミング言語を独自に作成するためのノウハウも広まってハードルが次第に下がってきている。

ウィキペディアに記事が掲載されているプログラミング言語を知りたい場合は[[プログラミング言語一覧]]を参照のこと。

== 分類・種類 ==
プログラミング言語の[[分類]]法は多数ある。

ひとつの分類法としては（そして計算機科学の教科書や情報処理技術者の教科書などで、まっさきに一種の定番のように挙げてある分類方法としては）、機械寄り（CPU寄り）か人間（の思考）寄りか、で分類する方法であり、'''[[低水準言語]]''' / '''[[高水準言語]]''' と分類する方法である。（" 低級言語 / 高級言語 " とも）
低水準言語の例としては、[[機械語]]の「命令コード」&lt;ref group="注釈"&gt;CPUの命令コードというのは、本当のCPUレベルではたとえば「00101011」のようにただの[[2進数]]の羅列であり、人間には意味不明である。&lt;/ref&gt;と1対1に対応する「命令語」&lt;ref group="注釈"&gt;数文字のアルファベットや数字を組み合わせて、CPUに対する命令やCPUが操作すべき[[レジスタ (コンピュータ)|レジスタ]]などを表記したもの。&lt;/ref&gt;を用いてプログラミングを行う[[アセンブリ言語]]がある。（機械語も低水準言語のひとつに数える場合もある。）対比される高水準言語の例としては[[Perl]]、[[Visual Basic]]、[[LISP]]、[[PHP (プログラミング言語)|PHP]]、[[Java]]、[[Python]]などを挙げることができる。（なお、境界はやや曖昧で、C言語はかつては「高水準言語」と見なされていたが、その後それよりもレベルの高い高水準言語が多数登場したので、今日ではメモリ管理もしないC言語は「低水準言語」に分類されることもある。）

他の分類法としては、[[実行 (コンピュータ)|実行]]方法によってプログラミング言語を分類する方法もあり、'''[[インタープリタ]]方式言語'''&lt;ref&gt;{{lang-en-short|interpreted language}}&lt;/ref&gt; / '''[[コンパイラ]]方式言語'''（コンパイル方式言語&lt;ref&gt;{{lang-en-short|compiled language}}&lt;/ref&gt;）と分類する方法である。
インタープリタ方式言語の例としてはPHPや[[Ruby]]を挙げることができる。コンパイラ方式言語の例としてはC言語、C++、[[Erlang]]、[[Haskell]]、[[Rust (プログラミング言語)|Rust]]、[[Go (プログラミング言語)|Go]]、FORTRAN、[[COBOL]]などを挙げることができる。なお言語によってはインタープリタ方式で実行でき、かつコンパイル方式で実行することができるものもある。そして「一応、どちらの方法でも実行できるが、基本はコンパイル方式」などという場合もあるので、やや分類が曖昧になる場合がある。コンパイル方式でしか実行できない言語をわざわざ指さなければならない場合に「純コンパイル方式言語&lt;ref&gt;{{lang-en-short|pure compiled language}}&lt;/ref&gt;」などと分類する人もいる&lt;ref&gt;[https://www.freecodecamp.org/news/compiled-versus-interpreted-languages/]&lt;/ref&gt;。なおJavaは[[バイトコード]]にコンパイルをしてから実行するので、一応「コンパイル方式」に分類することも可能ではある言語だが、[[実行時コンパイラ|実行時コンパイラ（JIT）]]と[[Java仮想マシン]]を使うので、「Javaは、コンパイル方式とインタープリタ方式の中間的な方式」としばしば指摘され、曖昧な位置づけである。

かつては人間側の用途で分類する方法もしばしば用いられたことがある。たとえば、[[汎用プログラミング言語]] / 事務計算用プログラミング言語/ 科学技術計算用プログラミング言語 などと分類する方法である。1970年代-1980年代などは「事務計算用プログラミング言語の例はCOBOLで、科学技術計算用プログラミング言語の例はFORTRAN」などと書かれたが、近年ではそのような分類はあまりされなくなった。なお「汎用プログラミング言語」に分類されるのはJava、[[C Sharp|C#]]、Python&lt;ref&gt;[https://www.slant.co/topics/15491/~general-purpose-programming-languages]&lt;/ref&gt;、Visual Basic、Rubyなどである。&lt;!-- 用途に基づいていない。出典が不適切。　用途にもとづいて分類する方法もあり、汎用言語 / システムプログラミング言語 / スクリプト言語 / ドメイン固有言語、並行/分散言語（あるいはこれらの混合）などがある&lt;ref&gt;{{cite web|url=http://tunes.org/wiki/programming_20languages.html|title=TUNES: Programming Languages |accessdate=2008年2月29日}}&lt;/ref&gt;。汎用言語の一部は教育目的で設計されている&lt;ref&gt;{{cite journal|last=Wirth|first=Niklaus|authorlink=ニクラウス・ヴィルト|title=Recollections about the development of Pascal|journal=Proc. 2nd ACM SIGPLAN conference on history of programming languages|pages=333–342|date=1993年 |url=http://portal.acm.org/citation.cfm?id=155378|accessdate=2006年6月30日}}&lt;/ref&gt;。--&gt;

手続き型言語&lt;ref&gt;[https://e-words.jp/w/%E6%89%8B%E7%B6%9A%E3%81%8D%E5%9E%8B%E8%A8%80%E8%AA%9E.html]&lt;/ref&gt;かそうでないかで、'''手続き型言語''' / '''[[非手続き型言語]]''' と分類する方法もある。手続き型言語の例としてはFORTRAN、[[ALGOL]]、C言語、COBOL、[[BASIC]]、[[Pascal]]などを挙げることができる。

[[オブジェクト指向プログラミング]]に適したしくみを備えているか否かで、'''[[オブジェクト指向言語]]''' / '''非オブジェクト指向言語''' と分類されることもある。

[[構造化プログラミング]]に適した仕様になっているか否かで判断して、適したものだけを'''構造化プログラミング言語'''&lt;ref&gt;{{lang-en-short|structured programming language}}&lt;/ref&gt;と分類する方法もある。&lt;!--&lt;ref group="注釈"&gt;[[非構造化プログラミング]]という用語は、「構造化プログラミング」という用語が出現した後に、それに分類できない言語群をさかのぼって（[[レッテル]]貼り的に）指すために[[レトロニム]]で、ややでっちあげぎみに作った用語なので、さすがにそれに適さない言語を " 非・構造化プログラミング言語 " と分類することまではしないのが一般的である。歴代の言語開発者は、わざわざ意図的にそういう状態になることを目指してプログラミング言語を開発したわけではないので、後世の人々が勝手にそんな呼び方をしてしまっては、あまりにも悪意がありすぎ、苦労を重ねた先人たち恩人たちに対する礼儀を欠きすぎ、そんな呼び方を平然とするようでは、人間性を疑われるからである。&lt;/ref&gt;--&gt;

[[スレッド (コンピュータ)|スレッド]]を複数個生成・管理できるか否か、で並行言語 / 非並行言語 と分類する方法もある。

なお1950年代（や1960年代）[[計算理論]]を[[チョムスキー階層]]という構想や理論が発表された時代には、計算表現能力に基づいてコンピュータの言語を、抽象的に、「タイプ0 / タイプ1 / タイプ2 / タイプ3」などに分類しようとしていたこともあった。ただし近年ではそのような分類法は滅多に持ち出されない。世の中のプログラミング言語のユーザーたちや言語開発者たちの関心は、すでに別のレベルに移っているからである&lt;ref group="注釈"&gt;なお[[チューリング完全]]な言語ならば、同じ[[アルゴリズム]]群を表現可能である。&lt;/ref&gt;。

（他の分野でもありがちなことなのだが）プログラミング言語も分類法があまりに多数あるので、混乱しがちな分類法を整理整頓しようと「分類法の分類」をする人も出てくる。たとえば高級言語の分類方法について「[[プログラミングパラダイム]]による分類法 / そうでない分類法」という分類ができる、などと言う人も出てくる。&lt;!--（プログラミングパラダイムは、[[手続き型プログラミング]] / [[オブジェクト指向プログラミング]] / [[関数型言語|関数型プログラミング]] / [[論理プログラミング]]などと分類できると言えばできるので、それによって 手続き型言語 / オブジェクト指向言語 / 関数型言語... などに分類したいと考える人もいるのだが、実際には各言語は2つ以上のパラダイムの性格を同時に併せ持つこともあり、つまり[[マルチパラダイムプログラミング言語|マルチパラダイム]]の場合もあるので、やはりこの方式でもすっきりと分類しきれるわけではない。おまけに低水準言語のアセンブラ言語はこの枠の外になってしまい、やはりすっきり分類できない&lt;ref group="注釈"&gt;なお、「[[分類]]」という記事を熟読すれば分かるが、そもそも「ものごとは、いつでもすっきりと分類できるはず」と思っているのが間違いなのである。世の中のほとんどのことは、すっきりとは分類できない。プログラミング言語も、&lt;u&gt;他の分野と同様に&lt;/u&gt;すっきりとは分類できない、というだけのことである。&lt;/ref&gt;。）--&gt;

以上のようにプログラミング言語の分類法は多数あるので、各プログラミング言語は複数のカテゴリに分類可能である。たとえばアセンブリ言語は「低水準言語」に分類され、かつ「非オブジェクト指向言語」に分類される。Javaは「高級言語」に分類され、かつ「オブジェクト指向言語」に分類され、かつ「並行性言語」に分類される。Pythonは「オブジェクト指向言語」であり「[[スクリプト言語]]」である。LISPは「マルチパラダイム言語」で「関数型言語」で「手続き型言語」である。

それ以外に、コンピュータがプリンター（やモニタ）などを制御するために使うプログラミング言語を分類するための「[[ページ記述言語]]」という分類法もある。
ページ記述言語の代表的な例としては、[[PostScript]]を挙げることができる。たとえば、プリンターで美麗な印字をする場合、画面上のボタンやメニューで「印刷」という命令を選ぶわけだが、その時点でPC内のプリンター制御用プログラムがPostScript言語でプログラムを自動生成し、そのプログラムをケーブルやWifi経由でプリンターに向けて送り出し、それを受け取ったプリンターの側でそれを実行するということで美麗な印字、繊細な曲線に満ちた[[フォント]]の印字を実現している。

その他に、あまり真面目な分類ではないが、わざわざ理解が難しくなるように作られた（冗談のような）プログラミング言語を特に「[[難解プログラミング言語]]」と分類することもある。

== 歴史 ==
{{see also|プログラミング言語年表}}

=== 初期の発展 ===
「コンピュータ」（という語）の定義次第ではあるが、それを「コンピュータ・プログラムによって駆動される機械」とするならば、コンピュータ・プログラムはコンピュータとともに生まれ、育ったということになり、そのプログラムの記法としてプログラミング言語があった、ということになる。[[チャールズ・バベッジ]]が[[階差機関]]に続いて計画した[[解析機関]]は、[[パンチカード]]の先祖と言えるような穴の開いた厚紙の列によって制御されるという機構を持っていたため、その特徴から「[[19世紀]]のコンピュータ」「蒸気動力のコンピュータ」などと呼ばれることがある。

[[20世紀]]初頭には、[[タビュレーティングマシン]]によって[[パンチカード]]を使ったデータの機械処理が始まっている。そういった実際面ばかりではなく[[計算理論]]としても、[[1930年代]]から[[1940年代]]にかけて、[[アルゴリズム]]を表現する数学的抽象表現を提供する[[ラムダ計算]]（[[アロンゾ・チャーチ]]）と[[チューリングマシン]]（[[アラン・チューリング]]）が考案された。ラムダ計算はその後の言語設計にも影響を与えている&lt;ref group="注釈"&gt;Benjamin C. Pierce は次のように書いている。
:". . . the lambda calculus has seen widespread use in the specification of programming language features, in language design and implementation, and in the study of type systems."（訳:ラムダ計算はプログラミング言語の仕様記述、言語設計と実装、型システムの研究に広く使われている）
{{cite book | last=Pierce | first=Benjamin C. | title=Types and Programming Languages | publisher=MIT Press | date=2002年 | id=ISBN 0-262-16209-1 | pages=52}}&lt;/ref&gt;。

1940年代、世界初の電子式デジタルコンピュータ群が製作された。[[1950年代]]初期のコンピュータである[[UNIVAC I]]や[[IBM 701]]では[[機械語]]を使っていた。機械語によるプログラミングは、間もなく[[アセンブリ言語]]によるプログラミングに取って代わられた。1950年代後半になると、アセンブリ言語で[[マクロ (コンピュータ用語)|マクロ命令]]が使われるようになり、その後 [[FORTRAN]]、[[LISP]]、[[COBOL]]という3つの[[高水準言語]]が開発された。これらは改良を加えられ現在でも使われており、その後の言語開発に重大な影響を与えた&lt;ref name="influences"&gt;{{cite web | url=http://www.oreilly.com/news/graphics/prog_lang_poster.pdf | type=pdf | title=History of programming languages | author=[[オライリーメディア|O'Reilly Media]] | accessdate=2006年10月5日}}&lt;/ref&gt;。1950年代末、[[ALGOL]]が登場し、その後の言語に様々な影響を与えている&lt;ref name="influences"/&gt;。初期のプログラミング言語の仕様と使い方は、当時のプログラミング環境の制約（パンチカードによるプログラム入力など）にも大きく影響されている&lt;ref&gt;Frank da Cruz. [http://www.columbia.edu/acis/history/cards.html IBM Punch Cards] [http://www.columbia.edu/acis/history/index.html Columbia University Computing History].&lt;/ref&gt;。

=== 改良 ===
[[1960年代]]から[[1970年代]]末ごろまでに、現在使われている主な言語パラダイムが開発されたが、その多くはごく初期の第三世代プログラミング言語のアイデアの改良である。
*[[APL]] - [[配列プログラミング]]を導入した言語。[[関数型言語|関数型プログラミング]]にも影響を与えた&lt;ref&gt;Richard L. Wexelblat: ''History of Programming Languages'', Academic Press, 1981, chapter XIV.&lt;/ref&gt;。
*[[PL/I]] (NPL) - FORTRANとCOBOLの長所を取り入れて1960年代初期に設計された。
*[[Simula]] - 世界初（1960年代）の[[オブジェクト指向プログラミング]]を採用した言語。1970年代中頃には純粋なオブジェクト指向言語である[[Smalltalk]]が登場した。
*[[C言語]] - 1969年から1973年にかけて[[システムソフトウェア|システムプログラミング]]言語として開発され、現在でもよく使われている&lt;ref&gt;{{cite web | url=http://www.cs.berkeley.edu/~flab/languages.html | author=François Labelle | title=Programming Language Usage Graph | work=Sourceforge | accessdate=2006年6月21日}}.  Sorceforge でのプロジェクト群で使われている言語の統計をとった結果である。C言語はよく使われているが、2006年には Java に抜かれている。ただし、C++を含めると一番多く使われていることになる。&lt;/ref&gt;。
*[[Prolog]] - 1972年に設計された[[論理プログラミング]]言語。
*[[ML (プログラミング言語)|ML]] - 1978年に開発された言語で、LISPをベースとした[[静的型付け]][[関数型言語]]の先駆けとなった。

これらの言語のアイデアは様々な言語に引き継がれており、現在の言語の多くは、これらのいずれかの系統に属する。

1960年代と1970年代は、[[構造化プログラミング]]に関する論争が盛んに行われた時期でもある&lt;ref&gt;{{Cite journal | title=The Semicolon Wars | journal=American Scientist | first1=Brian | last1=Hayes | volume=94 | issue=4 | date=2006年 | pages=pp. 299-303}}&lt;/ref&gt;。この論争で特に有名なものは、1968年にCommunications of the ACMに掲載された[[エドガー・ダイクストラ]]のレター''Go To Statement Considered Harmful''&lt;ref&gt;{{cite journal|last=Dijkstra|first=Edsger W.|authorlink=エドガー・ダイクストラ|title=Go To Statement Considered Harmful|journal=Communications of the ACM|volume=11|issue=3|date=March 1968|pages=147–148|url=http://www.acm.org/classics/oct95/|accessdate=2006年6月29日}}&lt;/ref&gt;であろう。その後の反論と指針としては[[ドナルド・クヌース|クヌース]]の''Structured Programming with go to Statements''がある。

1960年代と1970年代は、プログラムのメモリ使用量を削減し、プログラマやユーザーの生産性を向上させる技法も進展した時期である。初期の[[4GL]]（第四世代プログラミング言語）は、同じプログラムを第三世代プログラミング言語で書いたときよりもソースコードの量を劇的に削減した。

=== 統合と成長 ===
[[1980年代]]は、相対的な統合の時代であった。[[C++]]は、オブジェクト指向とシステムプログラミングの統合である。アメリカでは、軍需に使うことを目的として[[Ada]]というシステムプログラミング言語が標準化された。日本などでは、論理プログラミングを応用した[[第五世代コンピュータ|第五世代言語]]の研究に資源を費やした&lt;ref&gt; Tetsuro Fujise, Takashi Chikayama, Kazuaki Rokusawa, Akihiko Nakase (December 1994). "KLIC: A Portable Implementation of KL1" ''Proc. of FGCS '94, ICOT'' Tokyo, December 1994. [http://www.icot.or.jp/ARCHIVE/HomePage.html 第五世代コンピュータ・プロジェクト・アーカイブ]&lt;/ref&gt;。関数型言語コミュニティではMLとLISPの標準化の動きがあった。これらはいずれも新たなパラダイムを生み出そうというものではなく、それまでに生み出されたアイデアに改良を加える動きであった。

1980年代の重要な言語設計傾向の1つとして、大規模システムのためのプログラミングを目的として[[モジュール]]の概念を採り入れた点が挙げられる。1980年代にモジュールシステムを採り入れた言語として、[[Modula-2]]、Ada、MLがあるが、それ以前には、既に[[PL/I]]がモジュラープログラミングをサポートしていた。モジュールシステムは[[ジェネリックプログラミング]]の構成要素とされることが多い&lt;ref&gt;{{cite web|author=Jim Bender|url=http://readscheme.org/modules/|title=Mini-Bibliography on Modules for Functional Programming Languages|work=ReadScheme.org|accessdate=2006年9月27日|date=2004年3月15日}}&lt;/ref&gt;。

[[1990年代]]中頃には、[[インターネット]]の急激な成長によって新たな言語が生み出される機会が生じた。[[Perl]]は1987年にリリースされたUNIX上のスクリプト言語だったが、[[ウェブサイト]]の動的コンテンツ作成に使われるようになった。[[Java]]はサーバ側のプログラミングに使われるようになった。

== 要素 ==
=== 構文 ===
[[ファイル:Python_add5_syntax.svg|thumb|right|292px|[[シンタックスハイライト]]によりソースコードの構造や文法ミスを認識しやすくなる。ここでの言語は[[Python]]。]]
プログラミング言語の見た目は、その構文（syntax・[[統語論]]）で決定される。図形などを使う[[ビジュアルプログラミング言語|グラフィカルなプログラミング言語]]もあるが、たいていのプログラミング言語の[[ソースコード]]は[[文字列]]である。ファイル形式では[[プレーンテキスト]]すなわち[[テキストファイル]]が用いられる。

また、たいていのプログラミング言語では、まず、（英語では lexical syntax などと呼ぶ）ソースの文字列から空白類を取り除き最小の意味のあるカタマリを取り出した「[[字句]]（トークン）」があり、構文は字句の並びである、という扱いのことが多い。字句を切り出して分類する処理を[[字句解析]]、その並びを調べる処理を[[構文解析]]という。

（字句解析のために）字句規則を示すのには[[正規表現]]が、そして（構文解析のために）構文規則を示すのには[[バッカス・ナウア記法]]が使われることが多い。

下記は[[LISP]]の構文の一部分である。

#&lt;var&gt;expression&lt;/var&gt; ::= &lt;var&gt;atom&lt;/var&gt; | &lt;var&gt;list&lt;/var&gt;
#&lt;var&gt;atom&lt;/var&gt; ::= &lt;var&gt;number&lt;/var&gt; | &lt;var&gt;symbol&lt;/var&gt;
#&lt;var&gt;number&lt;/var&gt; ::= [&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;+&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;-&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;]?[&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;0&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;-&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;9&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;]+
#&lt;var&gt;symbol&lt;/var&gt; ::= [&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;A&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;-&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;Z&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;a&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;-&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;z&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;][^&lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt; &lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;]*
#&lt;var&gt;list&lt;/var&gt; ::= &lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;(&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt; &lt;var&gt;expression&lt;/var&gt;* &lt;nowiki&gt;'&lt;/nowiki&gt;&lt;code style="font-family:monospace;font-weight:bold"&gt;)&lt;/code&gt;&lt;nowiki&gt;'&lt;/nowiki&gt;

これは、次のような規則である。
* &lt;var&gt;expression&lt;/var&gt; は &lt;var&gt;atom&lt;/var&gt; または &lt;var&gt;list&lt;/var&gt; である。
* &lt;var&gt;atom&lt;/var&gt; は &lt;var&gt;number&lt;/var&gt; または &lt;var&gt;symbol&lt;/var&gt; である。
* &lt;var&gt;number&lt;/var&gt; は1文字以上の数字列であり、オプションとして符号が前置される（空白は含まない）。
* &lt;var&gt;symbol&lt;/var&gt; はアルファベットで始まる任意の文字列である（空白は含まない）。
* &lt;var&gt;list&lt;/var&gt; は括弧記号の対であり、その間に0個以上の &lt;var&gt;expression&lt;/var&gt; がある。

これに従う例として、&lt;code&gt;12345&lt;/code&gt;、&lt;code&gt;()&lt;/code&gt;、&lt;code&gt;(a b c232 (1))&lt;/code&gt; などがある。

構文上正しいプログラムが全て意味的に整合しているとは限らない、という設計の言語も多い&lt;ref group="注釈"&gt;自然言語では [[Colorless green ideas sleep furiously]]. という例文がある。&lt;/ref&gt;&lt;ref group="注釈"&gt;その言語の設計次第である。構文的に正しければ必ず整合した意味を持つような設計というものもありうる。&lt;/ref&gt;。また、意味的に整合していても、それを書いた人が、自分の意図を正しく反映できていない場合もある。

以下のLISPのコード断片は構文上は正しいが、意味的には問題がある。変数 &lt;code&gt;employees&lt;/code&gt; には従業員データのリストを入れるべきものであるが、&lt;code&gt;employees&lt;/code&gt; は実際には空（&lt;code&gt;nil&lt;/code&gt;）なので、&lt;code&gt;employees&lt;/code&gt; がリストであることを前提に、&lt;code&gt;employees&lt;/code&gt; の後続部分を求める式 &lt;code&gt;(cdr employees)&lt;/code&gt; は評価できずエラーになる。

&lt;syntaxhighlight lang="lisp"&gt;
(let ((employees nil))
  (cdr employees))
&lt;/syntaxhighlight&gt;

=== 意味 ===
自然言語の[[言語学]]に、そのプログラムが表現しているものは何か、というのが、プログラミング言語の「意味」である。たとえば「&lt;code&gt;a + b&lt;/code&gt; という式の値は、aの値とbの値を加算した値である」といったような規則の集まりであり、[[プログラム意味論]]という分野で形式的な意味論（[[形式意味論]]、{{lang-en-short|formal semantics}}）も研究されているが、C言語の標準規格など、自然言語で意味を与えている言語や、形式的でない擬似言語のようなもので与えている言語もある。

=== 型システム ===
{{Main|型システム}}
[[型システム]]は、プログラミング言語において式の値となる[[データ型]]について、[[型理論]]にもとづいて分類しどう扱うかを示すものである。

また、内部的には、ディジタルコンピュータでは全ての[[データ]]は[[バイナリ]]（[[二進法]]）で保持される。

==== 型のある言語とない言語 ====
型のある言語は、[[型システム]]によって、それぞれの値の[[データ型]]に応じて、定義されていない操作が実行されないよう（多かれ少なかれ）チェックされる機構を持つ&lt;ref name="typing"&gt;{{cite web | url=http://www.acooke.org/andrew/writing/lang.html#sec-types | author=Andrew Cooke | title=An Introduction to Programming Languages | accessdate=2006年6月30日}}&lt;/ref&gt;。

例えば、&lt;code&gt;"this text between the quotes"&lt;/code&gt; は文字列型の値である。ふつう、数を文字列で割る操作には意味がない。そのため、そのようなプログラムは拒絶する。言語によっては、コンパイル時に検出し（静的型検査）コンパイルを失敗とする。言語によっては、実行時に検出し（動的型検査）、例外とするものもあればなんらかのコアーション（型の強制）を行うものもある。（理論的には、静的なシステムのみを指して「[[型システム]]」とすることもある）

（型のある言語の特殊例として、単一型言語がある。[[REXX]]といったスクリプト言語や[[Standard Generalized Markup Language|SGML]]といったマークアップ言語は、単一のデータ型しか扱わない。多くの場合、そのときのデータ型は文字列型である。

[[アセンブリ言語]]などの型のない言語は、任意のデータに任意の操作を実行可能であり、データは単にある長さのビット列として扱われる&lt;ref name="typing"/&gt;。ある程度高い機能を持ちつつも型が無い（あるいは単一型の）プログラミング言語の例としては、[[BCPL]]や[[Forth]]などがある（型という概念自体が無いわけではない。例えば「浮動小数点に対する加算」という演算子といったものは存在する。ただしその演算子により、オペランドが何であれそのワードのビットパターンが浮動小数点数を表現しているものとみなされて加算される、といったようなことになる）。

「多かれ少なかれ」と書いたように、「強い」型システムの言語は少なく、多くの言語はそれなりの型システムを採用している&lt;ref name="typing"/&gt;。多くの実用的な言語には、型システムを迂回または打倒するような手段が用意されている。

==== 静的型付けと動的型付け ====
[[静的型付け]]（静的型付き言語&lt;ref&gt;{{lang-en-short|statically typed language}}&lt;/ref&gt;）では、全ての式の型はそのプログラムを実行する前（一般にコンパイル時）に決定される。例えば、1とか(2+2)という式は整数型であり、文字列を期待している関数には渡せず、日付（型）を格納するよう定義された変数には代入できない&lt;ref name="typing"/&gt;。

静的型付けでは、型を明記する場合と[[型推論]]を行う場合がある。前者ではプログラマは適切な位置に型を明記しなければならない&lt;ref group="注釈"&gt;たとえば変数の宣言などでは、その名前の直前ないし直後といったことが多い。ただしC言語では「void (*signal(int sig, void (*func)(int)))(int);」などといったように、いったいどこにあるのが名前なのか型なのか、全くわからないことになることがある。&lt;/ref&gt;。後者では、コンパイラが式の型を文脈から推論する。[[C++]]や[[Java]]などの主な静的型付き言語では、型を明記する。完全な型推論は主流でない言語に使われている（[[Haskell]]や[[ML (プログラミング言語)|ML]]）。ただし、型を明記する言語でも部分的な型推論をサポートしていることが多い。たとえば、[[Java]]や[[C Sharp|C#]]では限定された状況で型推論を行う。

[[動的型付け]]（動的型付き言語&lt;ref&gt;{{lang-en-short|dynamically typed language}}&lt;/ref&gt;）では、型の安全性は実行時に検査される。言い換えれば、型はソース上の式ではなく、実行時の値に対して付与される&lt;ref name="typing"/&gt;。型推論言語と同様、動的型付き言語でも式や変数の型を明記する必要はない。また、ある1つの変数がプログラム実行中に異なる型の値を格納することも可能である。しかし、コードを実際に実行してみるまで型の間違いを自動的に検出することができず、[[デバッグ]]がやや難しい。動的型付き言語としては、[[Ruby]]、[[LISP]]、[[JavaScript]]、[[Python]]などがある。

==== 強い型付けと弱い型付け ====
{{see|型システム#強い型付けと弱い型付け}}

=== 実行意味論 ===
データを入力されれば、コンピュータはそのデータに対して何らかの処理を実行する。「実行意味論({{lang-en-short|execution semantics}})」とは、プログラミング言語の構成要素がどの時点でどのようにして、そのプログラムの振る舞いを生成するのかを定義するものである。

例えば、式の[[評価戦略]]（[[先行評価]]、[[部分評価]]、[[遅延評価]]、[[短絡評価]]など）は実行意味論の一部である。また、[[制御構造]]における条件付実行の作法も実行意味論の一部である。

=== 標準ライブラリ ===
{{seealso|ランタイムライブラリ}}
「ライブラリ」は、プログラムを書いたり使用する上での、補助的なルーチン群である。多くのプログラミング言語には、言語仕様の一部、あるいは言語本体の仕様とは独立していることもあるが、標準[[ライブラリ]]の仕様もほぼ必ず存在し、その言語の実装には標準ライブラリの実装もほぼ必ず付属する。標準ライブラリには、典型的な[[アルゴリズム]]、[[データ構造]]、[[入出力]]機構などが含まれることが多い。

ユーザーから見れば、標準ライブラリも言語の一部だが、設計者から見れば別の実体である。言語仕様には必ず実装しなければならない部分が定義されており、標準化された言語の場合、それには標準ライブラリも含まれる。言語とその標準ライブラリの境界は、言語によって様々である。実際、言語によっては一部の言語機能が標準ライブラリなしでは使えないこともある（たとえば累乗の演算子がある言語があるが、それのコンパイル結果はその言語の多くの処理系で関数呼出であろう。それが、言語仕様として標準ライブラリの該当する関数を呼び出すよう決められているような場合は「一部の言語機能が標準ライブラリなしでは使えない」ということになる）。

マクロもライブラリに含まれることも多い。たとえばC言語の標準には、いくつかの名前が関数ではなくマクロで提供されるかもしれない、といったような規定などがある。また[[Lisp]]系の言語では、いわゆる特殊形式の多くが言語組込ではなくマクロでも実装可能であり、ifとcondのようにどちらか片方は必要だが、片方があればもう片方はマクロにできる、といったようなものもある。[[Scheme]]の標準規格は、どれを言語組込とし、どれをマクロとするか、ほとんどを処理系実装者の自由に任せている。

== 設計と実装 ==
コンピュータ・プログラミング言語の設計は「言語仕様」として示され、実装は「言語処理系」と呼ばれる。以下はそれらについての概観である。
=== 仕様 ===
前述のようにプログラミング言語は構文と意味から成るから、仕様についても、構文仕様と意味仕様がある。
==== 構文仕様 ====
構文仕様は一般に[[バッカス・ナウア記法]]などによって形式的に示される。
==== 意味仕様 ====
意味論の仕様は、自然言語などで記述されることが多いが、形式的に与えられている言語もある。

形式意味論（[[プログラム意味論]]の記事も参照）で意味論を記述した例として [[Standard ML]]&lt;ref&gt;{{cite book | last = Milner | first = R. | authorlink = ロビン・ミルナー| coauthors = M. Tofte, R. Harper and D. MacQueen. | title = The Definition of Standard ML (Revised) | publisher = MIT Press | date = 1997年 | id = ISBN 0-262-63181-4 }}&lt;/ref&gt; や [[Scheme]]&lt;ref&gt;{{cite web|first=Richard |last=Kelsey|coauthors=William Clinger and Jonathan Rees|title=Section 7.2  Formal semantics|work=Revised&lt;sup&gt;5&lt;/sup&gt; Report on the Algorithmic Language Scheme|url = http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.2| date=1998年2月|accessdate=2006年6月9日}}&lt;/ref&gt; がある。
=== その他 ===
他に、以下のようなスタイルで仕様が与えられている言語もある。

* その言語の処理系の[[リファレンス実装]]やモデル実装として示されているもの
** その言語の[[コンパイラ]]（FORTRAN）
** その言語の[[インタプリタ]]（Ruby（cruby、ただしRubyの標準化以前の場合））
** 対象言語自身で書かれることもある（例えば、[[LISP]] や [[Prolog]] や [[REXX|ANSI REXX]]&lt;ref&gt;[[ANSI]] — Programming Language Rexx, X3-274.1996&lt;/ref&gt;）[[:en:Meta-circular evaluator]] も参照のこと。

=== 処理系 ===
プログラミング言語の実装は、プログラミング言語処理系と呼ばれる。[[コンパイラ]]は、[[ソースコード]]などの入力を[[中間表現]]などの、より解釈実行しやすい表現に変換する処理系である。また、[[インタプリタ]]は、入力されたプログラムを解釈実行する処理系である（ハードウェアの[[プロセッサ]]は、[[機械語]]を解釈実行する[[インタプリタ]]である、と見ることができる）。

コンパイラとインタプリタの関係は、理論的には[[部分評価#二村射影|二村射影]]により定式化されている。

なお、「大きく分けて2つの方法がある。[[コンパイラ]]と[[インタプリタ]]である。一般にある言語をコンパイラとインタプリタの両方で実装することが可能である。」などといったように（従来書かれた通俗的解説書などには大変多いが）理解していると、Javaなど近年の多くの言語処理系のスタイルが全くわからない、ということになる。

（[[機械語]]にまで変換するもののみを指して[[コンパイラ]]と呼びたがる向きが一部にあり、その立場にもある程度は理もあるのだが、そうするとJavaの一般的な実装を指す用語が無くなる）

「コンパイラの出力したものをインタプリタで実行する方式は、コンパイラとインタプリタの区別が曖昧な場合もある。」などという変な説明をする者もいるが、前述したように、そもそも間違った2分法で考えているから、そのような変な考え方になるのである。

一般に、機械語に変換したもの（[[実行ファイル]]）を直接ハードウェアで実行する方が、インタプリタで実行するよりもずっと高速である。インタプリタでの実行を改善する技法として、[[実行時コンパイラ]]などの[[動的コンパイル]]手法がある。

&lt;!--
独自研究
== 意義と目的 ==
（コンピュータ）プログラミング言語は、おもに[[英語]]の単語と記号を組み合わせた（英語である必然性はひと欠片も無いが）、特殊な[[文法]]（正確には「構文」。誰にとって特殊かは不明だが）で記述される。その意義は、人とコンピュータの意思疎通を容易にするため、数字の羅列に代えて人間に扱いやすい言語形式を提供することにある。プログラミング言語があれば、人は扱いやすく理解できる言葉でコンピュータへの指示を書くことができる。プログラミング言語で書かれたコードは、[[アセンブリ言語#アセンブラ|アセンブラ]]、[[コンパイラ]]、[[インタプリタ]]など「プログラミング言語処理系」と呼ばれるプログラムによって処理（機械語あるいは[[中間表現]]に変換されたり、解釈実行されたり）される。
--&gt;

== 言語利用状況の計測 ==
どのプログラミング言語が最もよく使われているかを判断することは難しい。また、利用という意味も文脈によって異なる。プログラマの工数、[[コード行数|コードの行数]]、{{要出典範囲|CPU時間|date=2021年6月}}などが尺度として考えられる。ある言語は特定分野のアプリケーションだけでよく使われているということもある。例えば[[COBOL]]は企業のデータセンター（[[メインフレーム]]であることが多い）では今でも使われているし、[[FORTRAN]]は科学技術計算でよく使われ、[[C言語]]は組み込みシステムやオペレーティングシステムで使われている。

以下のように言語利用状況の尺度は様々であり、どれを選択しても一種のバイアスがかかっていると考えた方がよい。

* プログラマなどの求人広告で言語が言及されている回数&lt;ref&gt;[http://www.computerweekly.com/Articles/2007/09/11/226631/sslcomputer-weekly-it-salary-survey-finance-boom-drives-it-job.htm Survey of Job advertisements mentioning a given language]&lt;/ref&gt;
* 言語に関する書籍（入門書など）の販売部数&lt;ref&gt;[http://radar.oreilly.com/archives/2006/08/programming_language_trends_1.html Counting programming languages by book sales] {{webarchive|url=https://web.archive.org/web/20080517023127/http://radar.oreilly.com/archives/2006/08/programming_language_trends_1.html |date=2008年5月17日 }}&lt;/ref&gt;
* 言語ごとの既存のコード行数の推計。公開調査で見逃しやすい言語は少なく推定される傾向がある。&lt;ref&gt;Bieman, J.M.; Murdock, V., Finding code on the World Wide Web: a preliminary investigation, Proceedings First IEEE International Workshop on Source Code Analysis and Manipulation, 2001&lt;/ref&gt;
* 検索エンジンが見つけた各言語への参照の回数

=== 実際の指標の例 ===
* [https://www.tiobe.com/tiobe-index/ TIOBE Index]

&lt;!--
== 定義 ==
--&gt;
&lt;!--
; 機能

:プログラミング言語は[[プログラム (コンピュータ)|プログラム]]を書くのに使われる言語であり、それによって[[コンピュータ]]は何らかの計算&lt;ref&gt;{{cite web|author=[[Association for Computing Machinery|ACM]] SIGPLAN|title=Bylaws of the Special Interest Group on Programming Languages of the Association for Computing Machinery|url=http://www.acm.org/sigs/sigplan/sigplan_bylaws.htm|accessdate=2006年6月19日|date=2003年}}, ''The scope of SIGPLAN is the theory, design, implementation, description, and application of computer programming languages - languages that permit the specification of a variety of different computations, thereby providing the user with significant control (immediate or delayed) over the computer's operation.''&lt;/ref&gt;や[[アルゴリズム]]を実行し、場合によっては[[プリンター]]や[[ロボット]]&lt;ref name="robots"&gt;{{cite web|url=http://www.cs.brown.edu/people/tld/courses/cs148/02/programming.html |title=Programming Robots |accessdate=2006年9月23日 |last=Dean |first=Tom |date=2002年 |work=Building Intelligent Robots |publisher=Brown University Department of Computer Science}}&lt;/ref&gt;などの外部装置を制御する。
--&gt;
&lt;!-- 
{{要出典範囲|プログラミング言語には、[[データ構造]]を定義し操作する構成要素と、[[制御構造|実行の流れ]]を制御する構成要素がある。|date=2021年4月}}
--&gt;

== プログラミング言語と自然言語 ==
プログラミング言語は人間同士の会話と比較して、正確性と完全性の要求性が非常に高いという特徴がある。自然言語で人間同士が対話する場合、スペルミスや文法的なエラーがあっても相手は状況から適当に補正し、正確な内容を把握する。しかしコンピュータは指示が曖昧では動作せず、プログラマがコードに込めた意図を理解させることはできない。

プログラミングにおけるプログラミング言語の必要性を排除する方法として[[自然言語]]によるプログラムが構想されたり提案されることもあるが、その方向性は実用化には達しておらず、議論が続いている。[[エドガー・ダイクストラ]]は形式言語の使用によって意味のない命令を防ぐという立場で、自然言語によるプログラミングを批判していた&lt;ref&gt;Dijkstra, Edsger W. [http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD667.html On the foolishness of "natural language programming."] EWD667.&lt;/ref&gt;。[[アラン・パリス]]も同様の立場であった&lt;ref&gt;Perlis, Alan, [http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html Epigrams on Programming]. SIGPLAN Notices Vol. 17, No. 9, September 1982, pp. 7-13&lt;/ref&gt;。

このあたりの歴史的に錯綜した議論は、結局のところ「コンピュータを活用するにはプログラミングが必要であり、プログラミングはプログラミング言語で行われる」というある種の教条（[[ドグマ]]）が、次の2つの事象に分解されることで無意味な議論になった。すなわち「コンピュータをほどほどに活用する程度のことならば、各種アプリケーションソフトウェアや自然言語認識や自然言語処理技術の活用など（スマートスピーカーなど）により、利用者が自分でプログラミングすることは必ずしも必要ではなくなった」ということと「コンピュータのより徹底した活用、具体的にはそういった自然言語認識や自然言語処理のシステムそのものを作るには、プログラミングが必要ということは全く相変わらずであり、プログラミング言語の重要性は増えこそすれ、減りはしない」ということである。

;自然言語との違い
プログラミング言語は、もともと[[人間]]がコンピュータに命令を伝えその実行方法を指示するために作られたものであり、コンピュータが曖昧さなく解析できるように設計されている。多くの場合構文上の間違いは許されず、人間はプログラミング言語の文法に厳密にしたがった文を入力しなければならない。

これに対して、一般に[[自然言語]]の文法規則はプログラミング言語にくらべてはるかに複雑であり、例外も多い。ただしこれは規則が一般にいいかげんであったり、曖昧であるということではない。一般に自然言語の規則は奥が深く、驚くほどの非合理性に裏打ちされていることもあれば、驚くほどの合理性に裏打ちされていることもある。驚くほどの非合理性でも合理性でもないものに裏打ちされていることもあれば、驚くほどの裏打ちの無さがあることもある。

また、自然言語の意味は、その文脈（コンテキスト）によって定まる部分も多い。これに対して、プログラミング言語は、コンピュータによって扱いやすいように、文脈によって意味が変わることができるだけないように設計されているが、その文脈によって定まる部分がある場合も無くはない。たいていの言語にいくつかはある。

自然言語は、誤用や流行などにより長い時間をかけ、たくさんの人間の利用により、意図せざる形で変化していく。しかし、プログラミング言語の規則は、言語設計者の意図と作業によってのみ、変更される。実際には言語設計者が「たくさんの人間」である場合もあり（仕様が簡単な言語であれば多くの実装者がいることも多く、そういう場合は個々の実装ごとのその仕様があるとも言える）、長い時間をかけ、自然言語と全く同様にたくさんの人間の利用により変化してきたプログラミング言語もある（Lispなど）。また、プログラミング言語にも同様に流行があり、もともとの言語仕様では規定が無かったような一種の「誤用」に、後から仕様が定められる、といったことも必ずしも珍しくはない。

人間がふだん使っている[[日本語]]などの[[自然言語]]を使って[[コンピュータ]]に指示することができるのが理想ではある、と空想する者もいる。しかし、自然言語はあまりにも複雑で曖昧で変則的なので、それを機械語にコンパイルできるようなプログラムを作成することはとても難しい（コンパイルできるできないの問題ではなく、そもそもその意味が「複雑で曖昧で変則的」であること自体が問題なのだが、それを理解できない者が冒頭のように空想するのである）。そのような研究も進められているが、未だに汎用で実用になるプログラムは作成されたことがない。

そこで、自然言語よりも制限が強く、単純で厳密で規則的な人工言語を作って代用する。これが'''プログラミング言語'''である。プログラミング言語は自然言語よりもいくらか人間には扱いづらいが、機械語よりは遥かに親しみやすく、人間の指示の手間を軽減している。ちなみにコンピュータ向けの形式性と人間向けの柔軟性を兼ね備える[[ロジバン]]など、本来の開発目的が違えど潜在的に一つのプログラミング言語として機能しうるものもある。

大部分のプログラミング言語は、基本的には概ね[[文脈自由文法]]に沿っているが、プログラミング言語における文法的な制限は必ずしも全て文脈自由文法で表現できるとは限らず、文脈自由文法より制限されていることもあれば文脈自由文法より拡張されていることもあり、多くの場合は文脈自由文法には完全には沿っていない。

なおプログラミングへの応用も想定して設計された[[ロジバン]]のように、人間の言語とプログラミング言語の中間に位置するものがある。

==日本語における名称==
古い規格ではあるが[[日本産業規格]]の JIS X 3000 シリーズの規格名称では、全て「プログラム言語」になっている（例： JIS X 3001 プログラム言語 [[FORTRAN|Fortran]]、JIS X 3014 プログラム言語 [[C++]]）ため、それに合わせてプログラム言語と表記されることもあるが、英語では programming language であるため、それに合わせればプログラミング言語となり、近年ではプログラミング言語と表記されることが多い。&lt;ref group="注釈"&gt;1960年代、JISでは「プログラム言語」の訳語が用いられた（JIS C 6201-1967「電子計算機プログラム言語FORTRAN」）。このため'''プログラム言語'''としている例もJISをはじめとして広く見られるが、英フレーズ programming language に当てる語として{{要出典範囲|date=2019-08|必ずしも適切とは言えない。}}&lt;/ref&gt;

なお言語名が「C」や「D」のように1文字の名称の場合、そのままの表記では文章中に埋没してしまい判別しづらいなどの不都合がある場合もあるので、たとえ登録されている正式名称があくまで「C」などと一文字であっても、通常の文章中で表記する場合は、技術書なども含めて、しばしば「C言語」などと文字の後ろに「言語」を添えて表記される。

== 他 ==
&lt;!--扱っている内容については、「コンピュータプログラミング言語」（{{lang-en-short|computer programming language}}）に限定されていた--&gt;
{{要出典範囲|「コンピュータ以外でプログラマブルなものがある」「それのプログラミング言語がある」|date=2021年6月23日}}

== 参考文献 ==
{{参照方法|section=1|date=2021年4月}}
*Daniel P. Friedman, Mitchell Wand, Christopher Thomas Haynes: ''Essentials of Programming Languages'', The MIT Press 2001.
*David Gelernter, Suresh Jagannathan: ''Programming Linguistics'', The MIT Press 1990.
*Shriram Krishnamurthi: ''Programming Languages: Application and Interpretation'', [http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/ オンライン版].
*Bruce J. MacLennan: ''Principles of Programming Languages: Design, Evaluation, and Implementation'', Oxford University Press 1999.
*John C. Mitchell: ''Concepts in Programming Languages'', Cambridge University Press 2002.
*Benjamin C. Pierce: ''Types and Programming Languages'', The MIT Press 2002.
*Ravi Sethi: ''Programming Languages: Concepts and Constructs'', 2nd ed., Addison-Wesley 1996.
*Michael L. Scott: ''Programming Language Pragmatics'', Morgan Kaufmann Publishers 2005.
*Richard L. Wexelblat (ed.): ''History of Programming Languages'', Academic Press 1981.

== 脚注 ==
{{脚注ヘルプ}}
=== 注釈 ===
{{Notelist}}
=== 出典 ===
{{Reflist|2}}

== 関連項目 ==
* [[プログラミング言語一覧]]

== 外部リンク ==
*[https://www.tiobe.com/tiobe-index/ {{lang|en|TIOBE Index}}] - プログラミング言語の番付け
*[http://www.99-bottles-of-beer.net/ 99 Bottles of Beer] 同じプログラムを多数の言語で実装したコードを公開
*[https://www.levenez.com/lang/ Computer Languages History graphical chart]
*[http://cgibin.erols.com/ziring/cgi-bin/cep/cep.pl Dictionary of Programming Languages]
*[https://web.archive.org/web/20110220044217/http://hopl.murdoch.edu.au/ History of Programming Languages（HOPL）]
*[http://dmoz.org/Computers/Programming/Languages/ Open Directory - Computer Programming Languages]
*[http://merd.sourceforge.net/pixel/language-study/syntax-across-languages/ Syntax Patterns for Various Languages]
*[http://www.ulb.ac.be/di/rwuyts/INFO020_2003/grogono-evolution.pdf The Evolution of Programming Languages] by Peter Grogono
*[http://kikakurui.com/x3/index.html JIS（日本産業規格）X3（プログラム言語）]
* {{Kotobank}}

{{Normdaten}}
{{プログラミング言語一覧}}
{{プログラミング言語の関連項目}}
{{コンピュータ科学}}

{{DEFAULTSORT:ふろくらみんくけんこ}}
[[Category:プログラミング言語|*]]
[[Category:コンピュータ言語]]
[[Category:プログラミング]]</text>
      <sha1>48dbk30bfrqe3bm7sdkvfem57ltwhxj</sha1>
    </revision>
  </page>
  